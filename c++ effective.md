## 01：视c++为一个语言联邦
### 法则
* C++ 高效编程法则取决于使用c++的哪一部分
### 细节
#### c++是个多重范型编程语言
* 过程形式
* 对象形式
* 函数形式
* 泛型形式 （减小代码对特定数据类型的依赖）
* 元编程形式 （用代码生成代码，执行位于编译期）
#### c++的次语言
* C：区块、语句、预处理器、内置数据类型、数组、指针
* Object-Oriented（面向对象） C++：封装、继承、多态
* Template C+：泛型编程
* STL：泛型程序库，容器、迭代器、算法

## 02：尽量以const，enum，inline替换#define
### 法则
* 对于单纯常量，最好以const对象或enums替换#define
* 对于形如函数的宏， 最好改用inline函数替换#define
### 细节
#### #define的优点
* 方便程序修改
* 提高程序运行效率（函数调用）
* 编译时替换，所以不占用内存空间
#### #define的不足
* 预处理期间被替换，所用名称未记入记号表，编译出错难以定位错误。
* 预处理器会盲目替换掉所有的宏名称，导致目标代码出现多份其值的备份。
* 作用域是整个文件
* 实现表达式形式的宏，容易产生歧义
#### 用const的原因
* 对于基本数据类型，编译器会把它放到符号表中而不分配内存空间。
* const会进行类型安全检查。
* const会产生更小的目标代码。
#### 类专属常量的定义
* 可以声明成static const即可
* 定义需要在实现文件中定义 const double AClass::Value = 1.2;
	+ 若编译器支持在声明的时候设定初值，则定义只需要const double AClass::Value;
	+ 若不支持，则需要在定义式中设定初值。
* 可以用enum {value=1} 这种方式定义常量 （有作用域约束的define）
	+ 当编译期间要用到该常量
	+ 不可以获得地址，也不可以被指针指向
	+ 防止给不同的常量赋予相同的值
#### 用inline的好处
+ 继承define的好吃：函数的代码会被放入符号表中，在使用时展开，没有函数调用的开销，效率很高
+ 参数类型检测
+ 可以作为类的成员函数

## 03：尽量使用const
### 法则
* const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。
* 编译器强制实施bitwise constness，但编写程序时应该使用"概念上的常量性"。
* 当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。
### 细节
#### 指针常量的区分
* *号左边加const，是被指变量是常量
* *号右边加const，是指针本身是常量
* const_iterator, 是迭代器所指变量是常量
* const vector<int>::iterator, 是迭代器本身是常量
#### 函数返回值是const
* 防止函数调用后再被进行一次赋值（a*b）=c
	+ 内置类型会直接被检测不合法
	+ 内置类型想要被赋值，可以将返回值改成引用 比如 int& 
#### const成员函数
* 意义
	+ 容易被理解，知道哪个函数可以改动对象内容，哪个不行。
	+ 使操作const对象成为可能，这对编写高效代码而言是个关键。
* 只是常量性不同的函数，也是可以重载的。
#### bitwise const
+ const成员函数中没有改变任何值
#### mutable 
+ 释放掉non-static成员变量的bitwise constness约束
#### const和non-const的转型
+ 先将(*this)用static_cast转成const，再调用const函数，再将结果const_cast转换成非常量。
+ 反过来不可行，是因为在const函数中，不可改变对象的逻辑状态。
+ 避免代码重复。

