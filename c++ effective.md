## 01：视c++为一个语言联邦
### 法则
* C++ 高效编程法则取决于使用c++的哪一部分
### 细节
#### c++是个多重范型编程语言
* 过程形式
* 对象形式
* 函数形式
* 泛型形式 （减小代码对特定数据类型的依赖）
* 元编程形式 （用代码生成代码，执行位于编译期）
#### c++的次语言
* C：区块、语句、预处理器、内置数据类型、数组、指针
* Object-Oriented（面向对象） C++：封装、继承、多态
* Template C+：泛型编程
* STL：泛型程序库，容器、迭代器、算法

## 02：尽量以const，enum，inline替换#define
### 法则
* 对于单纯常量，最好以const对象或enums替换#define
* 对于形如函数的宏， 最好改用inline函数替换#define
### 细节
#### #define的不足
* 预处理期间被替换，所用名称未记入记号表，编译出错难以定位错误。
* 预处理器会盲目替换掉所有的宏名称，导致目标代码出现多份其值的备份。
* 作用域是整个文件
* 实现表达式形式的宏，容易产生歧义
#### 用const的原因
* 对于基本数据类型，编译器会把它放到符号表中而不分配内存空间。
* const会进行类型安全检查。
* const会产生更小的目标代码。
#### 类专属常量的定义
* 可以声明成static const即可
* 定义需要在实现文件中定义 const double AClass::Value = 1.2;
	+ 若编译器支持在声明的时候设定初值，则定义只需要const double AClass::Value;
	+ 若不支持，则需要在定义式中设定初值。
* 可以用enum {value=1} 这种方式定义常量 （有作用域约束的define）
	+ 不可以获得地址，也不可以被指针指向
	+ 防止给不同的常量赋予相同的值
#### 用inline的好处
+ 继承define的好吃：函数的代码会被放入符号表中，在使用时展开，没有函数调用的开销，效率很高
+ 参数类型检测
+ 可以作为类的成员函数


